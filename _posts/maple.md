# Maple内存技术的说明

### 摘要

针对Maple的架构，以尽量通俗的语言，对Maple的内存方案进行解释，并给出对这个领域的见解。第一节介绍背景。第二节简单介绍两种内存方案的原理以及优缺点。第三节给出Maple方案的决策。第四节给出结论。第五节为对未来相关领域的预测。第六节是我的个人感想。

### 1. 背景介绍
内存垃圾的回收主要发生在“内存安全”的编程语言中，比如Java。这些语言需要依靠虚拟机（或者运行时系统）里面特定的技术回收不再使用的内存，这就是通常说的垃圾回收，也可以认为是自动回收。而c/c++之类的语言则要求程序员主动回收。本文的关注点在于垃圾自动回收的两种常见技术，一种通常称为GC（Garbage collection，垃圾回收），另一种通常称为RC（Reference Counting，引用计数）。

Maple的内存回收方案采用RC为主GC为辅的组合方案。本文将对这两种方案进行分析并给出架构设计的主要依据。

### 2. RC/GC 分析

#### 2.1 GC简介
GC技术的根本思想：（1）在程序运行中如果发现内存使用过度，就把程序停下来，启动GC算法来回收不用的数据所占用的内存。此时，正常程序被停止，如果是多线程，则所有正常的线程全部停止。这就是臭名昭著的stop world。（2）GC首先从某些特定的已经预先认定的活跃数据出发，搜寻他们会引用的数据，认定这些新的数据也活跃，再以这些新数据为基础，找到他们会引用的数据，并认定为活跃数据。以此类推，不断遍历，直到所有活跃数据认定完毕。（3）至此，那些没有被认定为活跃的数据就是可以回收的垃圾。算法按照特定方法来回收没用的内存垃圾。（4）当回收结束，则重新启动正常的程序。

GC最大的优点是一次性可以把不用的内存都给回收掉。

GC最大的缺点就是stop world，把程序停止。这个停止时间的长短是GC算法的关键。通常的停止一般在几十到几百毫秒。现在有很多研究宣称可以做到1ms，这些一般是在某些实验室研究里得到的比较理想的数据，这种研究数据对于实际产品项目没有参考价值。

在手机场景下，特别是重度场景（负荷高时间长的场景，比如喜欢打游戏的用户），GC stop world如果超过16ms，则会感觉不流畅，如果在战争游戏里面则会出现发呆并被敌人爆头的结果。如果超过40ms，则人眼可以明显感觉屏幕停顿，手机没有反应。这就是著名的卡顿。如果一天发生几次卡顿，用户就会投诉，甚至退货。投诉和退货率是终端部门最关心的。

GC的第二大缺点就是由于会Stop world，因此不能老是频繁的调用，只能等内存垃圾足够多的时候在激活它。因此会有垃圾堆积的现象，引起内存紧缺。

#### 2.2 RC简介
RC的基本思想：（1）给每一个数据对象分配一个计数，叫引用计数（Reference Count，也是这个算法名字的由来）。（2）当有数据B引用数据A的时候，则把A的计数加一；如果B不再活跃了，则把A的计数减一。（3）当数据A的计数为0的时候，则可以立即回收A占用的内存。

RC最大的优点是：只要数据没人用了，则可以立即回收。因此非常及时，可以认为是实时的。不需要停止程序，也没有垃圾堆积的现象。而且回收的速度很快，不需要遍历所有的数据，只是针对单个数据操作。

RC最大的缺点是：会有环引用（cycle reference）导致垃圾无法回收。比如上面的B引用了A，如果A又引用了B，那么他们的计数都会停留在1，永远都是活的。这就是环引用。这个时候就需要采用额外的算法来打破这个环，从而回收垃圾。此处不展开。

#### 2.3 RC和GC 一个重大区别 
RC和GC还有一个重大区别。RC更多的是依赖编译器在编译的时候就行算法的实现，因此比较多的用在许多静态编译的语言，比如Swift, Rust等。RC的优化大多数都可以通过编译器实现。GC更多的是依靠虚拟机或者运行时算法解决，编译器一般没有更多的机会对它进行优化。

这点在下一节决策过程中扮演重要角色。

#### 2.4 小结
不管RC还是GC，都有各自非常鲜明的优缺点。

另外，他们都有一些其他比较明显的缺点，但没有前面罗列的那么严重。比如两者都需要额外的代码来完成工作。RC需要额外代码去计数并判断是否计数为0，GC则需要插入代码好让程序停下来以方便GC算法启动（这就是yield point）。两者也都要一些额外的数据结构来存储辅助的信息。本文不展开了。

我认为，不存在一个技术先进另外一个落后的说法。我们在选择方案的时候需要分析使用的场景，根据各自优缺点来判断，选择最适合需要的，而不是认为某种算法放之四海而皆准。


### 3. Maple的决策

Maple内存回收方案的决策依据是两个。一是项目的落地标准，二是内存回收如何最优的融入整体技术方案。

#### 3.1 产品特点的要求
Maple的目标是要解决安卓手机的卡顿问题，前文已经描述过了，手机产品最关注的就是重度场景的表现。实际测量结果已经证明，在重度场景下，GC引起的卡顿往往在几十毫秒甚至几百毫秒，内存压力也很大。这也是大家熟知的安卓手机比较卡的主要原因。另外手机也面临着要不断增加内存的压力，引起成本上升。

在这种情况下，GC显然不适合解决手机重度场景的问题。
#### 3.2 项目整体方案的要求

另外一个方面，内存回收应该如何最优融入项目的整体方案。

Maple是一个复杂工程，它尝试用静态编译的方法把Java代码直接编译成二进制执行文件，消除虚拟机的存在。当然会失去平台无关性，但是对于终端手机来说，不需要平台无关。这个项目成功的关键是要尽最大可能发掘静态分析的优势，尽可能把动态运行时开销在静态时解决掉。这个过程的技术问题非常多，包括（1）编译优化，这个内容太多，不展开了；（2）Java语言特性如何静态编译，特别是反射、异常和虚函数等，内存回收也属于这个范畴；（3）跟安卓的兼容，这里包括程序的启动（我们设计了与zygote同等的进程），native函数的接口处理，跨语言数据类型的转换，等等。内存回收只是所有问题中的一个。

前面提到过，RC是非常适合编译器在静态编译的时候完成，并且对于Maple这样一个系统来说，里面本身要部署大量的编译时优化，这些优化技术都是可以直接应用到RC的优化上面。可以说，RC作为Maple的一部分，和其他编译优化直接是相辅相成的。从纯粹技术的角度来看，选择RC是顺理成章的。

但是前面也提到过，RC无法解决环引用的问题，因此，最终决定在Maple系统里也部署一个后备用的GC，以解决这类问题。

#### 3.3 Maple内存回收的最终方案

最终方案是以RC为主，GC为辅。GC的调用次数很少，我们都设置在低负荷或者休眠的时候进行。后期针对环引用我们又引进了很多技术，从而RC可以发挥更大的能量，进一步降低GC调用的次数，一天24小时只需要个位数。


### 4.结论
Maple最终非常成功，各方面数据都是达到了预期，甚至超越预期。这些都是通过用户大数据反应的，是最真实的。这也证明我们的选择是正确的。

### 5.未来的技术走向
这节是我个人的理解，仅供参考。

GC的研究现在仍旧非常活跃，这其实也是因为它的问题足够引起人们重视。研究的核心思想还是要减少stop world的次数和降低这个时间。采用的办法就是将原来一个长时间的stop world划分成无数的小的Stop world或者尽量把工作平摊减少Stop world里面的工作量，以达到1ms这样的目标。从理论上看，有点向RC靠拢，将大任务分割成小任务。当然，实现方法是不同的。核心思想都是要降低峰值。GC在这个努力的过程中是消耗了大量的其他地方的计算时间和内存资源，或者说，把工作量转移到其他地方了。这点paper里面一般不会详细描述。

Stop world是GC无法跨越的鸿沟。虽然许多研究论文都宣称降到1ms一下，但实际场景中经常可以看到几十到几百毫秒的卡顿。

现在的新语言的研究已经逐步偏向RC，偏向静态编译，比较典型的就是swift和rust。Rust甚至提供RC的模板类型。

当然，RC的环引用问题必须解决，现在一般都是在语言上解决，要求程序员来协助一起完成。一般都会提供弱引用（Weak Reference）等供程序员使用。弱引用不会被计数，从而打破了环。
### 6. 个人感想
Maple发展到今天，已经是一个完整的编程体系，并不是一个简单的Java编译器。已经发布了Java编译器，C编译器，Java引擎和JS引擎，还有跨语言调试器，多语言前端。这些都在gitee上面。我们一直坚持一个信念，要建立一个方舟特色的全栈编程体系。我和我的兄弟们都会为之奋斗。



